import{r as e}from"./react-CLV34zfu.js";import{t as n,v as s}from"./index-BKfe1cCG.js";const t={},a=(e,n,s,a)=>{c(s)&&t[s]||(c(s)&&(t[s]=new Date),((e,n,s,t)=>{const a=[s,{code:n,...t||{}}];if(e?.services?.logger?.forward)return e.services.logger.forward(a,"warn","react-i18next::",!0);c(a[0])&&(a[0]=`react-i18next:: ${a[0]}`),e?.services?.logger?.warn?e.services.logger.warn(...a):console})(e,n,s,a))},r=(e,n)=>()=>{if(e.isInitialized)n();else{const s=()=>{setTimeout(()=>{e.off("initialized",s)},0),n()};e.on("initialized",s)}},o=(e,n,s)=>{e.loadNamespaces(n,r(e,s))},i=(e,n,s,t)=>{if(c(s)&&(s=[s]),e.options.preload&&e.options.preload.indexOf(n)>-1)return o(e,s,t);s.forEach(n=>{e.options.ns.indexOf(n)<0&&e.options.ns.push(n)}),e.loadLanguages(n,r(e,t))},c=e=>"string"==typeof e,u=e.createContext();class l{constructor(){this.usedNamespaces={}}addUsedNamespaces(e){e.forEach(e=>{this.usedNamespaces[e]||(this.usedNamespaces[e]=!0)})}getUsedNamespaces(){return Object.keys(this.usedNamespaces)}}const g=(e,n,s,t)=>e.getFixedT(n,s,t),d=(t,r={})=>{const{i18n:d}=r,{i18n:f,defaultNS:p}=e.useContext(u)||{},m=d||f||s();if(m&&!m.reportNamespaces&&(m.reportNamespaces=new l),!m){a(m,"NO_I18NEXT_INSTANCE","useTranslation: You will need to pass in an i18next instance by using initReactI18next");const e=(e,n)=>{return c(n)?n:"object"==typeof(s=n)&&null!==s&&c(n.defaultValue)?n.defaultValue:Array.isArray(e)?e[e.length-1]:e;var s},n=[e,{},!1];return n.t=e,n.i18n={},n.ready=!1,n}m.options.react?.wait&&a(m,"DEPRECATED_OPTION","useTranslation: It seems you are still using the old wait option, you may migrate to the new useSuspense behaviour.");const N={...n(),...m.options.react,...r},{useSuspense:h,keyPrefix:w}=N;let y=p||m.options?.defaultNS;y=c(y)?[y]:y||["translation"],m.reportNamespaces.addUsedNamespaces?.(y);const b=(m.isInitialized||m.initializedStoreOnce)&&y.every(e=>((e,n,s={})=>n.languages&&n.languages.length?n.hasLoadedNamespace(e,{lng:s.lng,precheck:(n,t)=>{if(s.bindI18n&&s.bindI18n.indexOf("languageChanging")>-1&&n.services.backendConnector.backend&&n.isLanguageChangingTo&&!t(n.isLanguageChangingTo,e))return!1}}):(a(n,"NO_LANGUAGES","i18n.languages were undefined or empty",{languages:n.languages}),!0))(e,m,N)),x=((n,s,t,a)=>e.useCallback(g(n,s,t,a),[n,s,t,a]))(m,r.lng||null,"fallback"===N.nsMode?y:y[0],w),E=()=>x,I=()=>g(m,r.lng||null,"fallback"===N.nsMode?y:y[0],w),[T,v]=e.useState(E);let C=y.join();r.lng&&(C=`${r.lng}${C}`);const O=((n,s)=>{const t=e.useRef();return e.useEffect(()=>{t.current=n},[n,s]),t.current})(C),S=e.useRef(!0);e.useEffect(()=>{const{bindI18n:e,bindI18nStore:n}=N;S.current=!0,b||h||(r.lng?i(m,r.lng,y,()=>{S.current&&v(I)}):o(m,y,()=>{S.current&&v(I)})),b&&O&&O!==C&&S.current&&v(I);const s=()=>{S.current&&v(I)};return e&&m?.on(e,s),n&&m?.store.on(n,s),()=>{S.current=!1,m&&e&&e?.split(" ").forEach(e=>m.off(e,s)),n&&m&&n.split(" ").forEach(e=>m.store.off(e,s))}},[m,C]),e.useEffect(()=>{S.current&&b&&v(E)},[m,w,b]);const k=[T,m,b];if(k.t=T,k.i18n=m,k.ready=b,b)return k;if(!b&&!h)return k;throw new Promise(e=>{r.lng?i(m,r.lng,y,()=>e()):o(m,y,()=>e())})};export{d as u};
